---
layout: post
title:  "Bashing my head against Zsh, part 1"
date:   2020-08-29 16:02:01 -0400
categories: jekyll update
---
As promised in my [last post]({% post_url 2020-08-29-welcome %}), this is
the documentation of my adoption of the Z shell (zsh), which is the default
user shell as of MacOS Catalina. Hitherto I've used the Bourne-Again Shell
(bash).

I live and work at the command line. Virtually all my professional time – what
isn't spent in the web browser – is spent typing at the shell prompt. So I've
invested a significant chunk of that time over the years in getting my
environment just so. And while I'm always tweaking and adding to those
customizations, I haven't really revisited most of them since the last time I
changed login shells, from the Korn Shell (ksh) – which was over 20 years ago
now.

So while I had resisted the change for a while, I have finally taken the plunge.
I am, of course, hardly the first to do so or to document it, as a web search
will reveal; there's even [a
book](https://www.amazon.com/Bash-Shell-Conquering-Command-Line/dp/1590593766)
on the topic. As I find useful posts from previous adventurers
online, I'll link to them here. But the particulars of my setup will
necessarily be different, and I hope that seeing what I'm doing and why will
help you make your shell environment easier to get things done in. 

Some housekeeping first: while Catalina comes with a `/bin/zsh`, it is slightly
out of date: version 5.7.1. Plus, I use a couple Macs that I have kept back
on Mojave for various reasons, which has an even older version; I want my
shell environment to be consistent across my usual machines. So I have
used [Homebrew](https://brew.sh) to install the latest version in
/usr/local/bin, which as of this writing is 5.8. I'll try to point out when I'm
doing something that won't work in older versions. 

To ensure that I'm always running the correct zsh, I have this in my ~/.zshrc
file (see below):

    if [[ $(zsh -c 'echo $ZSH_VERSION') > $ZSH_VERSION ]]; then
      exec zsh ${-+-$-} "$@"
    fi

The condition should prevent an infinite loop. :) 

But that brings us to our first topic: startup files. 

## Zdots and Profiles and Env files, Oh my! 

When it comes to shell startup files, zsh has an embarassment of riches. That's basically a multiple-inheritance problem; Zsh is directly inspired by bash and
tcsh, which were in turn inspired by ksh and the original csh, and all those
influences accumulate.

The original Bourne shell only sourced any files automatically in login shells;
these files would presumably set everything they needed in the form of
environment variables that child shells would inherit. So you got
`/etc/profile` and `$HOME/.profile` exeucted on initial login, and that was it.

David Korn and team recognized the need to perform some shell initialization
that wasn't automatically inherited by child processes. So one of the things
you could do in the `.profile` for ksh was set a parameter called `$ENV` to the
name of a file; interactive shells would read that file on startup. The most
common name for the environment file was `.kshrc`, so later versions of ksh
look for a `.kshrc` if `$ENV` isn't set.

Meanwhile, the C shells had `.[t]cshrc` for all shells and `.login` for login
shells, but ran them in that order; `.login` was executed _after_ `.cshrc`. They also introduced the complementary `.logout` file, which is executed right 
before a login shell exits. (You could arrange for something like this in the
Bourne or Korn shells via `trap`, but there was no file executed
automatically.)

Bash tried to incorporate the best features of the Korn and C shells while
maintaining compatibility with the Bourne shell.  So login shells run
`/etc/profile` just like the Bourne shell, and then look the first of
`.bash_profile`, `.bash_login`, or `.profile` that exists in the user's home
directory. And if there's a `.bash_logout` file, it gets run just before a login shell exits.

But the `.kshrc` and `$ENV` functions have been split in Bash. The
`~/.bashrc` file gets executed in interactive shells, while non-interactive
ones look for a file to execute in the parameter `$BASH_ENV`.  Bash also lets 
you specify a different file to run instead of .bashrc with the `--rcfile` 
option, or tell it not to run one at all with `--norc`.

So with all that history, what did Zsh do? Well, it uses something
similar to the bash model, but a little less complicated, modified to
allow more familiarity for csh users. 

The first thing it does is allow you to put your dotfiles somewhere other
than your home directory; if `$ZDOTDIR` is set in the environment, it
will look in there instead. The filenames are unchanged, though; even
in a ZDOTDIR, they start with a period.

Zsh runs global and local versions of these files in this order:

    /etc/zshenv
        This file is always run, regardless of whether the shell is login or
        not, interactive or not. There's no way to stop zsh from executing
        this file. It can, however, stop zsh from executing any others - if 
        the environment variable GLOBAL_RCS is unset, then none ofthe other
        `/etc` files will be read; if `RCS` is unset, then none of the user's
        personal startup files will be read. Otherwise, we continue:

    ${ZDOTDIR-$HOME}/.zshenv
        Assuming RCS is still set after /etc/zshenv, this file is run - 
        again for all shells, regardless of interactivity or login status.
        So anything that should be set in absolutely all zsh processes goes
        here. Some users set their environment variables in here, so that
        they're set even for shells that aren't children of login shells (which
        can happen in a GUI terminal environment). But I have Terminal and
        iTerm configured to start my shells as login shells, and so far have
        not found anything I need to put in here.

    /etc/zprofile
    ${ZDOTDIR-$HOME}/.zprofile
        These run in login shells only. My .zprofile is where I set environment
        variables.

    /etc/zshrc
    ${ZDOTDIR-$HOME}/.zshrc
        These run for interactive shells only. Command completion, aliases,
        functions you use at the command line - these should all be set up
        here.

    /etc/zlogin
    ${ZDOTDIR-$HOME}/.zlogin
        This runs on login shells only, just like `.zprofile`, but after the
        .zshrc, so you have the same sequence as the C shells for folks used to
        those. I don't use it, at least not yet.

    /etc/zlogout
    ${ZDOTDIR-$HOME}/.zlogout
         Run before exiting a login shell. I don't do anything with this
         either.

### My Setup 
My home directory dotfiles are actually symlinks into a clone
of a GitHub repo where I maintain configuration files, personal scripts, etc. The shell dotfiles live in files named `lib/`_shellname_`/`_startupfile_`/main`, which
source other files in the same subdirectory. That way I can keep things
organized with related settings together in the same file. While I could
put all the symlinks for zsh directly in `lib/zsh` and set ZDOTDIR, I
don't currently do that.

My .zshenv currently has this in it:

    if [[ $fpath[(ie)$HOME/lib/zsh/functions] > ${#fpath[@]} ]]; then
      fpath=($HOME/lib/zsh/functions $fpath)
    fi

I used to set FPATH in the profile and export it, but I might run other
shells that also use FPATH, and don't want them trying to run zsh functions,
or vice-versa. So I set it for every zsh shell and don't export it.

My `.zprofile` (actually `lib/zsh/zprofile/main`) is pretty barebones at the
moment:

    if [[ $path[(ie)/usr/local/bin] > ${#path[@]} ]]; then
      path=($HOME/bin /usr/local/bin /usr/local/sbin $path)
      export PATH
    fi

    # This turns off the auto-paging feature of AWS CLI 2.x
    export AWS_PAGER=

In both of these files you can see I'm already embracing some zshisms,
most notably the inherited csh feature that makes path variables automatically
available in array form under the lowercase version of their name. This makes
them much easier to manipulate programmatically. 

I'm also taking advantage of the fact that zsh lets you expand array elements
without curly braces: `$arrayVar[$index]` instead of `${arrayVar[$index]}`. And
using a couple of its expansion modifier flags, which show up in parenteheses
after the opening delimiter of expansion expressions like array subscripts.
Here, the `(i)` flag _inverts_ the lookup, so it returns the index at which the
element matches the string supplied as a subscript; the `(e)` _exact_ flag means
that match has to be exact.  If the string is not found, the expansion returns
a number greater than the length of the array. So both of the above `if` 
statements are performing simple "is this item in the array" checks.

So that's it for my `.zshenv` and `.zprofile`. My `.zshrc`, on the other hand,
is already approaching 100 lines, and I have another 180 lines in shell
function definitions. But we'll talk about all of those settings as ther
categories come up in the following posts.

Next time: Prompts!
